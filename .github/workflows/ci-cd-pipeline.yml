name: Lugx Gaming CI/CD Pipeline - Production Only

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  schedule:
    # Run integration tests every 4 hours for ongoing reliability
    - cron: '0 */4 * * *'

env:
  DOCKER_REGISTRY: docker.io
  DOCKER_USERNAME: spmani99
  AWS_REGION: us-east-1
  EKS_CLUSTER_NAME: lugx-gaming-cluster

jobs:
  # Job 1: Detect Changed Services
  detect-changes:
    name: Detect Changed Services
    runs-on: ubuntu-latest
    outputs:
      frontend-changed: ${{ steps.changes.outputs.frontend }}
      game-service-changed: ${{ steps.changes.outputs.game-service }}
      order-service-changed: ${{ steps.changes.outputs.order-service }}
      analytics-service-changed: ${{ steps.changes.outputs.analytics-service }}
      any-changes: ${{ steps.changes.outputs.any }}
      
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Detect Service Changes
      id: changes
      run: |
        echo "Detecting which services have changed..."
        
        # Get list of changed files
        if [ "${{ github.event_name }}" = "schedule" ]; then
          # For scheduled runs, check all services
          echo "Scheduled run - checking all services"
          FRONTEND_CHANGED=true
          GAME_SERVICE_CHANGED=true
          ORDER_SERVICE_CHANGED=true
          ANALYTICS_SERVICE_CHANGED=true
        else
          # Get changed files from git diff
          CHANGED_FILES=$(git diff --name-only ${{ github.event.before }} ${{ github.event.after }} 2>/dev/null || git diff --name-only HEAD~1 HEAD)
          
          echo "Changed files:"
          echo "$CHANGED_FILES"
          
          # Check which services have changes
          FRONTEND_CHANGED=false
          GAME_SERVICE_CHANGED=false
          ORDER_SERVICE_CHANGED=false
          ANALYTICS_SERVICE_CHANGED=false
          
          if echo "$CHANGED_FILES" | grep -q "^frontend/\|^\.github/"; then
            FRONTEND_CHANGED=true
          fi
          
          if echo "$CHANGED_FILES" | grep -q "^game-service/\|^\.github/"; then
            GAME_SERVICE_CHANGED=true
          fi
          
          if echo "$CHANGED_FILES" | grep -q "^order-service/\|^\.github/"; then
            ORDER_SERVICE_CHANGED=true
          fi
          
          if echo "$CHANGED_FILES" | grep -q "^analytics-service/\|^\.github/"; then
            ANALYTICS_SERVICE_CHANGED=true
          fi
        fi
        
        # Check if any service changed
        ANY_CHANGED=false
        if [ "$FRONTEND_CHANGED" = "true" ] || [ "$GAME_SERVICE_CHANGED" = "true" ] || [ "$ORDER_SERVICE_CHANGED" = "true" ] || [ "$ANALYTICS_SERVICE_CHANGED" = "true" ]; then
          ANY_CHANGED=true
        fi
        
        # Set outputs
        echo "frontend=$FRONTEND_CHANGED" >> $GITHUB_OUTPUT
        echo "game-service=$GAME_SERVICE_CHANGED" >> $GITHUB_OUTPUT
        echo "order-service=$ORDER_SERVICE_CHANGED" >> $GITHUB_OUTPUT
        echo "analytics-service=$ANALYTICS_SERVICE_CHANGED" >> $GITHUB_OUTPUT
        echo "any=$ANY_CHANGED" >> $GITHUB_OUTPUT
        
        echo "Detection results:"
        echo "Frontend changed: $FRONTEND_CHANGED"
        echo "Game Service changed: $GAME_SERVICE_CHANGED"
        echo "Order Service changed: $ORDER_SERVICE_CHANGED"
        echo "Analytics Service changed: $ANALYTICS_SERVICE_CHANGED"
        echo "Any changes: $ANY_CHANGED"

  # Job 2: Build and Test Frontend
  build-frontend:
    name: Build & Test Frontend
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.frontend-changed == 'true'
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ env.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_TOKEN }}
        
    - name: Docker Metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.DOCKER_USERNAME }}/frontend
        tags: |
          type=sha,format=long
          type=raw,value=latest,enable={{is_default_branch}}
          
    - name: Build and Push Docker Image
      uses: docker/build-push-action@v5
      with:
        context: ./frontend
        platforms: linux/amd64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        
    - name: Run Unit Tests
      run: |
        echo "Running unit tests for frontend"
        cd frontend
        npm install
        npm test || echo "Tests completed with warnings"

  # Job 3: Build and Test Game Service
  build-game-service:
    name: Build & Test Game Service
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.game-service-changed == 'true'
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ env.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_TOKEN }}
        
    - name: Docker Metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.DOCKER_USERNAME }}/game-service
        tags: |
          type=sha,format=long
          type=raw,value=latest,enable={{is_default_branch}}
          
    - name: Build and Push Docker Image
      uses: docker/build-push-action@v5
      with:
        context: ./game-service
        platforms: linux/amd64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        
    - name: Run Unit Tests
      run: |
        echo "Running unit tests for game-service"
        cd game-service
        npm install
        npm test || echo "Tests completed with warnings"

  # Job 4: Build and Test Order Service
  build-order-service:
    name: Build & Test Order Service
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.order-service-changed == 'true'
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ env.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_TOKEN }}
        
    - name: Docker Metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.DOCKER_USERNAME }}/order-service
        tags: |
          type=sha,format=long
          type=raw,value=latest,enable={{is_default_branch}}
          
    - name: Build and Push Docker Image
      uses: docker/build-push-action@v5
      with:
        context: ./order-service
        platforms: linux/amd64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        
    - name: Run Unit Tests
      run: |
        echo "Running unit tests for order-service"
        cd order-service
        npm install
        npm test || echo "Tests completed with warnings"

  # Job 5: Build and Test Analytics Service
  build-analytics-service:
    name: Build & Test Analytics Service
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.analytics-service-changed == 'true'
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ env.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_TOKEN }}
        
    - name: Docker Metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.DOCKER_USERNAME }}/analytics-service
        tags: |
          type=sha,format=long
          type=raw,value=latest,enable={{is_default_branch}}
          
    - name: Build and Push Docker Image
      uses: docker/build-push-action@v5
      with:
        context: ./analytics-service
        platforms: linux/amd64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        
    - name: Run Unit Tests
      run: |
        echo "Running unit tests for analytics-service"
        cd analytics-service
        npm install
        npm test || echo "Tests completed with warnings"

  # Job 6: Security Scanning (only for changed services)
  security-scan:
    name: Security Scanning
    runs-on: ubuntu-latest
    needs: [detect-changes, build-frontend, build-game-service, build-order-service, build-analytics-service]
    if: always() && needs.detect-changes.outputs.any-changes == 'true'
    strategy:
      matrix:
        service: [frontend, game-service, order-service, analytics-service]
        exclude:
          - service: frontend
            skip: ${{ needs.detect-changes.outputs.frontend-changed != 'true' }}
          - service: game-service
            skip: ${{ needs.detect-changes.outputs.game-service-changed != 'true' }}
          - service: order-service
            skip: ${{ needs.detect-changes.outputs.order-service-changed != 'true' }}
          - service: analytics-service
            skip: ${{ needs.detect-changes.outputs.analytics-service-changed != 'true' }}
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      
    - name: Run Trivy Vulnerability Scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.DOCKER_USERNAME }}/${{ matrix.service }}:latest
        format: 'sarif'
        output: 'trivy-results.sarif'
        
    - name: Upload Trivy Scan Results
      uses: github/codeql-action/upload-sarif@v3
      continue-on-error: true
      with:
        sarif_file: 'trivy-results.sarif'

  # Job 7: Deploy to Production (Rolling Deployment)
  deploy-production:
    name: Deploy to Production (Rolling Deployment)
    runs-on: ubuntu-latest
    needs: [detect-changes, build-frontend, build-game-service, build-order-service, build-analytics-service, security-scan]
    if: always() && github.ref == 'refs/heads/main' && needs.detect-changes.outputs.any-changes == 'true'
    environment: production
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'
        
    - name: Connect to EKS Cluster
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}
        kubectl config current-context
        
    - name: Pre-deployment Health Check
      run: |
        echo "Running pre-deployment health check..."
        chmod +x .github/scripts/health-check.sh
        .github/scripts/health-check.sh default
        
    - name: Rolling Deployment to Production (Zero Downtime)
      run: |
        echo "Starting rolling deployment to production for 100% uptime..."
        
        # Apply all Kubernetes manifests
        echo "Applying Kubernetes manifests..."
        kubectl apply -f frontend/frontend-deployment.yaml
        kubectl apply -f frontend/frontend-secret.yaml
        kubectl apply -f game-service/game-service-deployment.yaml
        kubectl apply -f order-service/order-service-deployment.yaml
        kubectl apply -f analytics-service/analytics-service-deployment.yaml
        kubectl apply -f ingress.yaml
        
        # Clean any stuck pods first
        echo "Cleaning any pending/failed pods..."
        kubectl delete pods --field-selector=status.phase=Pending --force --grace-period=0 || true
        kubectl delete pods --field-selector=status.phase=Failed --force --grace-period=0 || true
        
        # Deploy only changed services
        echo "Deploying changed services..."
        
        if [ "${{ needs.detect-changes.outputs.frontend-changed }}" = "true" ]; then
          echo "Deploying frontend with rolling update strategy..."
          kubectl set image deployment/frontend-deployment frontend=${{ env.DOCKER_USERNAME }}/frontend:${{ github.sha }} || true
          kubectl patch deployment frontend-deployment -p '{"spec":{"strategy":{"type":"RollingUpdate","rollingUpdate":{"maxUnavailable":0,"maxSurge":1}}}}' || true
          kubectl rollout status deployment/frontend-deployment --timeout=300s || true
          echo "Frontend deployment completed"
        fi
        
        if [ "${{ needs.detect-changes.outputs.game-service-changed }}" = "true" ]; then
          echo "Deploying game-service with rolling update strategy..."
          kubectl set image deployment/game-service-deployment game-service=${{ env.DOCKER_USERNAME }}/game-service:${{ github.sha }} || true
          kubectl patch deployment game-service-deployment -p '{"spec":{"strategy":{"type":"RollingUpdate","rollingUpdate":{"maxUnavailable":0,"maxSurge":1}}}}' || true
          kubectl rollout status deployment/game-service-deployment --timeout=300s || true
          echo "Game service deployment completed"
        fi
        
        if [ "${{ needs.detect-changes.outputs.order-service-changed }}" = "true" ]; then
          echo "Deploying order-service with rolling update strategy..."
          kubectl set image deployment/order-service-deployment order-service=${{ env.DOCKER_USERNAME }}/order-service:${{ github.sha }} || true
          kubectl patch deployment order-service-deployment -p '{"spec":{"strategy":{"type":"RollingUpdate","rollingUpdate":{"maxUnavailable":0,"maxSurge":1}}}}' || true
          kubectl rollout status deployment/order-service-deployment --timeout=300s || true
          echo "Order service deployment completed"
        fi
        
        if [ "${{ needs.detect-changes.outputs.analytics-service-changed }}" = "true" ]; then
          echo "Deploying analytics-service with rolling update strategy..."
          kubectl set image deployment/analytics-service-deployment analytics-service=${{ env.DOCKER_USERNAME }}/analytics-service:${{ github.sha }} || true
          kubectl patch deployment analytics-service-deployment -p '{"spec":{"strategy":{"type":"RollingUpdate","rollingUpdate":{"maxUnavailable":0,"maxSurge":1}}}}' || true
          kubectl rollout status deployment/analytics-service-deployment --timeout=300s || true
          echo "Analytics service deployment completed"
        fi
        
        echo "Rolling deployment completed!"
        echo "Production URL: http://lugx-games.local"
        
    - name: Post-deployment Health Check
      run: |
        echo "Running post-deployment health check..."
        chmod +x .github/scripts/health-check.sh
        .github/scripts/health-check.sh default
        
    - name: Generate Deployment Report
      run: |
        echo "Generating deployment report..."
        chmod +x .github/scripts/generate-report.sh
        .github/scripts/generate-report.sh default

  # Job 8: Integration Tests (Post-Deployment)
  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: deploy-production
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'
        
    - name: Connect to EKS Cluster
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}
        
    - name: Run Integration Tests
      run: |
        echo "Running comprehensive integration tests..."
        chmod +x .github/scripts/integration-tests.sh
        .github/scripts/integration-tests.sh production
        
    - name: Verify RDS and ClickHouse Connectivity
      run: |
        echo "Verifying database and analytics connectivity..."
        
        # Check RDS connectivity through game service
        echo "Testing RDS connectivity via Game Service..."
        GAME_POD=$(kubectl get pods -l app=game -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
        if [ -n "$GAME_POD" ]; then
          kubectl logs $GAME_POD --tail=10 | grep -i "connected\|database\|error" || echo "Game service logs checked"
        fi
        
        # Check ClickHouse connectivity through analytics service
        echo "Testing ClickHouse connectivity via Analytics Service..."
        ANALYTICS_POD=$(kubectl get pods -l app=analytics -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
        if [ -n "$ANALYTICS_POD" ]; then
          kubectl logs $ANALYTICS_POD --tail=10 | grep -i "clickhouse\|connected\|error" || echo "Analytics service logs checked"
        fi

  # Job 9: Periodic Integration Tests (Ongoing Reliability)
  periodic-integration-tests:
    name: Periodic Integration Tests
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'
        
    - name: Connect to EKS Cluster
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}
        
    - name: Run Periodic Health Checks
      run: |
        echo "Running periodic health checks for ongoing reliability..."
        chmod +x .github/scripts/health-check.sh
        .github/scripts/health-check.sh default
        
    - name: Run Periodic Integration Tests
      run: |
        echo "Running periodic integration tests..."
        chmod +x .github/scripts/integration-tests.sh
        .github/scripts/integration-tests.sh production
        
    - name: Generate Periodic Report
      run: |
        echo "Generating periodic system report..."
        chmod +x .github/scripts/generate-report.sh
        .github/scripts/generate-report.sh default

  # Job 10: Rollback on Failure
  rollback:
    name: Rollback on Deployment Failure
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: failure() && github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'
        
    - name: Connect to EKS Cluster
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}
        
    - name: Execute Automatic Rollback
      run: |
        echo "Deployment failed - executing automatic rollback..."
        chmod +x .github/scripts/rollback.sh
        .github/scripts/rollback.sh default
        
    - name: Verify Rollback Success
      run: |
        echo "Verifying rollback success..."
        chmod +x .github/scripts/health-check.sh
        .github/scripts/health-check.sh default
        
        echo "Rollback completed. System restored to previous stable state."