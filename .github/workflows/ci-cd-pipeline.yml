name: 🎮 Lugx Gaming CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  schedule:
    # Run integration tests every 4 hours for reliability monitoring
    - cron: '0 */4 * * *'

env:
  DOCKER_REGISTRY: docker.io
  DOCKER_USERNAME: spmani99
  AWS_REGION: us-east-1
  EKS_CLUSTER_NAME: lugx-gaming-cluster
  
jobs:
  # Job 1: Build and Test
  build-and-test:
    name: 🔨 Build & Test Services
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        service: [frontend, game-service, order-service, analytics-service]
        
    outputs:
      frontend-image: ${{ steps.meta.outputs.tags }}
      game-service-image: ${{ steps.meta.outputs.tags }}
      order-service-image: ${{ steps.meta.outputs.tags }}
      analytics-service-image: ${{ steps.meta.outputs.tags }}
      
    steps:
    - name: 📥 Checkout Code
      uses: actions/checkout@v4
      
    - name: 🐳 Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: 🔑 Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ env.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}
        
    - name: 📋 Extract Metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.DOCKER_USERNAME }}/${{ matrix.service }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          
    - name: 🔨 Build and Push Docker Image
      uses: docker/build-push-action@v5
      with:
        context: ./${{ matrix.service }}
        platforms: linux/amd64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        
    - name: 🧪 Run Unit Tests
      run: |
        echo "🧪 Running unit tests for ${{ matrix.service }}"
        # Add unit test commands here based on service type
        if [ "${{ matrix.service }}" = "frontend" ]; then
          docker run --rm ${{ env.DOCKER_USERNAME }}/${{ matrix.service }}:latest npm test -- --coverage --watchAll=false
        elif [ "${{ matrix.service }}" != "frontend" ]; then
          docker run --rm ${{ env.DOCKER_USERNAME }}/${{ matrix.service }}:latest npm test
        fi

  # Job 2: Security Scanning
  security-scan:
    name: 🔒 Security Scanning
    runs-on: ubuntu-latest
    needs: build-and-test
    
    strategy:
      matrix:
        service: [frontend, game-service, order-service, analytics-service]
        
    steps:
    - name: 📥 Checkout Code
      uses: actions/checkout@v4
      
    - name: 🔍 Run Trivy Vulnerability Scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.DOCKER_USERNAME }}/${{ matrix.service }}:latest
        format: 'sarif'
        output: 'trivy-results.sarif'
        
    - name: 📤 Upload Trivy Scan Results
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  # Job 3: Deploy to Staging (Rolling Deployment)
  deploy-staging:
    name: 🚀 Deploy to Staging (Rolling)
    runs-on: ubuntu-latest
    needs: [build-and-test, security-scan]
    if: github.ref == 'refs/heads/develop'
    environment: staging
    
    steps:
    - name: 📥 Checkout Code
      uses: actions/checkout@v4
      
    - name: ⚙️ Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: 🔧 Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'
        
    - name: 🎯 Connect to EKS Cluster
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}
        
    - name: 🏷️ Create Staging Namespace
      run: |
        kubectl create namespace lugx-staging --dry-run=client -o yaml | kubectl apply -f -
        
    - name: 🔄 Rolling Deployment to Staging
      run: |
        echo "🚀 Starting rolling deployment to staging..."
        
        # Update image tags in deployment files
        services=("frontend" "game-service" "order-service" "analytics-service")
        
        for service in "${services[@]}"; do
          echo "📦 Deploying $service to staging..."
          
          # Update deployment with new image
          kubectl set image deployment/${service}-deployment ${service}=${{ env.DOCKER_USERNAME }}/${service}:${{ github.sha }} -n lugx-staging
          
          # Wait for rollout to complete
          kubectl rollout status deployment/${service}-deployment -n lugx-staging --timeout=300s
          
          # Check deployment health
          kubectl get pods -n lugx-staging -l app=${service}
        done
        
    - name: 🧪 Run Integration Tests - Staging
      run: |
        echo "🧪 Running integration tests on staging..."
        chmod +x .github/scripts/integration-tests.sh
        .github/scripts/integration-tests.sh staging

  # Job 4: Deploy to Production (Blue-Green)
  deploy-production:
    name: 🎯 Deploy to Production (Blue-Green)
    runs-on: ubuntu-latest
    needs: [deploy-staging]
    if: github.ref == 'refs/heads/main'
    environment: production
    
    steps:
    - name: 📥 Checkout Code
      uses: actions/checkout@v4
      
    - name: ⚙️ Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: 🔧 Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'
        
    - name: 🎯 Connect to EKS Cluster
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}
        
    - name: 🔵 Blue-Green Deployment Setup
      run: |
        echo "🔵 Setting up Blue-Green deployment..."
        
        # Determine current active environment
        if kubectl get namespace lugx-blue > /dev/null 2>&1; then
          CURRENT_ENV="blue"
          NEW_ENV="green" 
        else
          CURRENT_ENV="green"
          NEW_ENV="blue"
        fi
        
        echo "📊 Current active: lugx-$CURRENT_ENV"
        echo "🆕 Deploying to: lugx-$NEW_ENV"
        echo "CURRENT_ENV=$CURRENT_ENV" >> $GITHUB_ENV
        echo "NEW_ENV=$NEW_ENV" >> $GITHUB_ENV
        
    - name: 🏗️ Deploy to New Environment
      run: |
        echo "🚀 Deploying to lugx-${{ env.NEW_ENV }}..."
        
        # Create new environment namespace
        kubectl create namespace lugx-${{ env.NEW_ENV }} --dry-run=client -o yaml | kubectl apply -f -
        
        # Apply secrets to new environment
        kubectl apply -f frontend/frontend-secret.yaml -n lugx-${{ env.NEW_ENV }}
        kubectl apply -f game-service/game-db-secret.yaml -n lugx-${{ env.NEW_ENV }}
        kubectl apply -f order-service/order-db-secret.yaml -n lugx-${{ env.NEW_ENV }}
        kubectl apply -f analytics-service/analytics-secret.yaml -n lugx-${{ env.NEW_ENV }}
        
        # Deploy services with updated images
        services=("frontend" "game-service" "order-service" "analytics-service")
        
        for service in "${services[@]}"; do
          echo "📦 Deploying $service to lugx-${{ env.NEW_ENV }}..."
          
          # Create temporary deployment file with updated image and namespace
          sed "s|image: spmani99/${service}:latest|image: spmani99/${service}:${{ github.sha }}|g" ${service}/${service}-deployment.yaml > temp-${service}-deployment.yaml
          sed -i "s|namespace: default|namespace: lugx-${{ env.NEW_ENV }}|g" temp-${service}-deployment.yaml
          
          kubectl apply -f temp-${service}-deployment.yaml
          
          # Wait for deployment to be ready
          kubectl rollout status deployment/${service}-deployment -n lugx-${{ env.NEW_ENV }} --timeout=600s
          
          rm temp-${service}-deployment.yaml
        done
        
    - name: 🧪 Run Integration Tests - Production
      run: |
        echo "🧪 Running integration tests on new production environment..."
        chmod +x .github/scripts/integration-tests.sh
        .github/scripts/integration-tests.sh production ${{ env.NEW_ENV }}
        
    - name: 🔄 Switch Traffic (Blue-Green)
      run: |
        echo "🔄 Switching traffic to lugx-${{ env.NEW_ENV }}..."
        
        # Update ingress to point to new environment
        kubectl patch ingress lugx-gaming-ingress -p '{"spec":{"rules":[{"host":"lugx-games.local","http":{"paths":[{"path":"/","pathType":"Prefix","backend":{"service":{"name":"frontend","port":{"number":80}}}}]}}]}}' -n lugx-${{ env.NEW_ENV }}
        
        # Wait for ingress update
        sleep 30
        
        # Final health check
        echo "🏥 Final health check..."
        .github/scripts/health-check.sh ${{ env.NEW_ENV }}
        
    - name: 🧹 Cleanup Old Environment
      run: |
        echo "🧹 Cleaning up old environment: lugx-${{ env.CURRENT_ENV }}"
        
        # Wait 5 minutes before cleanup (ensure traffic has switched)
        sleep 300
        
        # Delete old environment (optional - can keep for rollback)
        # kubectl delete namespace lugx-${{ env.CURRENT_ENV }} --ignore-not-found=true
        
        echo "✅ Blue-Green deployment completed successfully!"

  # Job 5: Periodic Integration Tests (Reliability Monitoring)
  periodic-integration-tests:
    name: 🔄 Periodic Integration Tests
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'
    
    steps:
    - name: 📥 Checkout Code
      uses: actions/checkout@v4
      
    - name: ⚙️ Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: 🔧 Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'
        
    - name: 🎯 Connect to EKS Cluster
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}
        
    - name: 🧪 Run Periodic Reliability Tests
      run: |
        echo "🔄 Running periodic integration tests for reliability monitoring..."
        chmod +x .github/scripts/integration-tests.sh
        .github/scripts/periodic-tests.sh
        
    - name: 📊 Generate Test Report
      run: |
        echo "📊 Generating reliability test report..."
        chmod +x .github/scripts/generate-report.sh
        .github/scripts/generate-report.sh
        
    - name: 📤 Upload Test Results
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: periodic-test-results
        path: test-results/
        
    - name: 🚨 Log Test Failure
      if: failure()
      run: |
        echo "🚨 Periodic integration tests failed!"
        echo "Check the workflow logs and test results for details."
        echo "Failed at: $(date)"

  # Job 6: Rollback on Failure
  rollback:
    name: 🔙 Rollback on Failure
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: failure() && github.ref == 'refs/heads/main'
    
    steps:
    - name: 📥 Checkout Code
      uses: actions/checkout@v4
      
    - name: ⚙️ Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: 🔧 Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'
        
    - name: 🎯 Connect to EKS Cluster
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}
        
    - name: 🔙 Execute Rollback
      run: |
        echo "🔙 Executing rollback to previous stable version..."
        chmod +x .github/scripts/rollback.sh
        .github/scripts/rollback.sh
        
    - name: 🚨 Log Rollback Completion
      run: |
        echo "🔙 Production deployment failed. Rollback executed to previous stable version."
        echo "Check the deployment logs for failure details."
        echo "Rollback completed at: $(date)"